<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>圆形区域展开</title>
  <style>
    body{
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      margin:0; padding:20px;
      background:#f5f5f5;
      display:flex; flex-direction:column; align-items:center;
    }
    .container{
      background:#fff;
      padding:20px;
      border-radius:12px;
      box-shadow:0 4px 12px rgba(0,0,0,0.08);
      max-width:900px;
      width:100%;
      box-sizing:border-box;
      text-align:center;
    }
    .hint{
      font-size:12px; color:#666; margin:6px 0 14px;
      line-height:1.5;
    }
    canvas{
      touch-action:none;
      max-width:100%;
      background:#eee;
      border-radius:6px;
      margin:12px 0;
      user-select:none;
      cursor:grab;
    }
    canvas:active{ cursor:grabbing; }
    .controls{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin:10px 0 16px;
      align-items:center;
    }
    .controls .group{
      display:flex;
      gap:10px;
      align-items:center;
      padding:6px 10px;
      background:#fafafa;
      border:1px solid #eee;
      border-radius:10px;
    }
    label{ font-size:13px; color:#333; }
    select, button, input[type="file"]::file-selector-button{
      padding:8px 12px;
      border-radius:8px;
      border:1px solid #ddd;
      background:#fff;
      font-size:14px;
    }
    button, input[type="file"]::file-selector-button{
      border:none;
      background:#007bff;
      color:#fff;
      cursor:pointer;
      transition:background 0.2s;
    }
    button:hover, input[type="file"]::file-selector-button:hover{ background:#0056b3; }
    button:disabled{ opacity:0.6; cursor:not-allowed; }
    input[type="file"]{ margin-bottom:10px; }
    #result-container{
      display:none;
      margin-top:18px;
      border-top:1px solid #eee;
      padding-top:16px;
    }
    .note{
      font-size:12px;
      color:#666;
      margin-top:6px;
      min-height:16px;
    }
    .radio{
      display:flex;
      gap:10px;
      align-items:center;
      font-size:13px;
      color:#333;
    }
    .radio input{ transform:translateY(1px); }
  </style>
</head>
<body>
  <div class="container">
    <h2 style="margin:0 0 6px;">圆形区域展开</h2>
    <div class="hint">
      上传图片后，在左侧调整你想要的圆形区域，点击“生成结果”。<br/>
      默认操作：拖动图片位置，滚轮/捏合缩放图片（圆框固定）。也可以切到“编辑圆框”模式。
    </div>

    <input type="file" id="upload" accept="image/jpeg, image/png, image/webp" />

    <div>
      <canvas id="editor" width="0" height="0"></canvas>
    </div>

    <div class="controls">
      <div class="group">
        <div class="radio" title="默认更符合常见裁剪器的使用习惯">
          <label><input type="radio" name="mode" value="fixed" checked /> 固定圆框</label>
          <label><input type="radio" name="mode" value="edit" /> 编辑圆框</label>
        </div>
      </div>

      <div class="group">
        <label for="outScale">清晰度</label>
        <select id="outScale">
          <option value="1.2" selected>标准（更快）</option>
          <option value="2.0">高</option>
          <option value="3.0">超高（更慢）</option>
        </select>
      </div>

      <div class="group">
        <label for="outCap">输出上限</label>
        <select id="outCap">
          <option value="1024">1024</option>
          <option value="2048" selected>2048（默认）</option>
          <option value="4096">4096</option>
          <option value="0">无上限</option>
        </select>
      </div>

      <div class="group">
        <label for="interp">采样方式</label>
        <select id="interp">
          <option value="linear" selected>平滑（Linear）</option>
          <option value="nearest">像素（Nearest）</option>
          <option value="mipmap">高质量缩小（MipMap）</option>
        </select>
      </div>

      <button id="process-btn">生成结果</button>
    </div>

    <div id="note" class="note"></div>

    <div id="result-container">
      <h3 style="margin:0 0 8px;">结果预览</h3>
      <canvas id="output" width="0" height="0"></canvas>
      <div class="controls" style="margin-top:12px;">
        <button id="dl-png">下载 PNG</button>
        <button id="dl-jpg">下载 JPG</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const upload = document.getElementById('upload');
  const editor = document.getElementById('editor');
  const output = document.getElementById('output');
  const processBtn = document.getElementById('process-btn');
  const resultContainer = document.getElementById('result-container');
  const noteEl = document.getElementById('note');

  const outScaleSel = document.getElementById('outScale');
  const outCapSel = document.getElementById('outCap');
  const interpSel = document.getElementById('interp');
  const dlPngBtn = document.getElementById('dl-png');
  const dlJpgBtn = document.getElementById('dl-jpg');

  const ctx = editor.getContext('2d');

  // ---- 状态：图像 ----
  let img = null;

  // ---- 状态：模式 ----
  /** fixed: 圆框固定、移动/缩放图片；edit: 圆框可拖拽/缩放 */
  let mode = 'fixed';

  // ---- 状态：编辑圆框（image space）----
  let cx = 0, cy = 0, r = 0;

  // ---- 状态：固定圆框（canvas space frame） + 图片变换（canvas space）----
  let frameX = 0, frameY = 0, frameR = 0;
  let imgScale = 1;
  let imgTx = 0, imgTy = 0;

  // ---- 交互状态 ----
  let isDragging = false;
  let lastX = 0, lastY = 0;
  let lastDist = 0;
  let lastPinchCenterX = 0, lastPinchCenterY = 0;

  function setNote(msg) {
    noteEl.textContent = msg || '';
  }

  function getEventPos(e, isTouch = false, index = 0) {
    const rect = editor.getBoundingClientRect();
    const scaleX = editor.width / rect.width;
    const scaleY = editor.height / rect.height;
    const clientX = isTouch ? e.touches[index].clientX : e.clientX;
    const clientY = isTouch ? e.touches[index].clientY : e.clientY;
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY,
      rawX: clientX,
      rawY: clientY,
      rect,
      scaleX,
      scaleY
    };
  }

  function clampSelection() {
    if (!img) return;
    const maxR = Math.min(img.width, img.height) / 2;
    r = Math.max(10, Math.min(r, maxR));
    cx = Math.max(r, Math.min(cx, img.width - r));
    cy = Math.max(r, Math.min(cy, img.height - r));
  }

  function minScaleToCoverFrame() {
    if (!img) return 1;
    // 让图片至少覆盖圆框（避免露出空白）
    const needW = (2 * frameR) / img.width;
    const needH = (2 * frameR) / img.height;
    return Math.max(needW, needH, 0.05);
  }

  function clampImageTransform() {
    if (!img) return;

    const minS = minScaleToCoverFrame();
    imgScale = Math.max(minS, Math.min(imgScale, 20));

    const w = img.width * imgScale;
    const h = img.height * imgScale;

    // 约束：圆框必须完全落在图片覆盖范围内
    const minTx = (frameX + frameR) - w;
    const maxTx = (frameX - frameR);
    const minTy = (frameY + frameR) - h;
    const maxTy = (frameY - frameR);

    imgTx = Math.min(maxTx, Math.max(minTx, imgTx));
    imgTy = Math.min(maxTy, Math.max(minTy, imgTy));
  }

  function drawEditor() {
    if (!img) return;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, editor.width, editor.height);

    if (mode === 'fixed') {
      // 先画变换后的图片
      ctx.save();
      ctx.setTransform(imgScale, 0, 0, imgScale, imgTx, imgTy);
      ctx.drawImage(img, 0, 0);
      ctx.restore();

      // 再画遮罩（挖洞）
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, 0, editor.width, editor.height);
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.arc(frameX, frameY, frameR, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // 边框
      ctx.beginPath();
      ctx.arc(frameX, frameY, frameR, 0, Math.PI * 2);
      ctx.strokeStyle = '#28a745';
      ctx.lineWidth = 3;
      ctx.stroke();
    } else {
      // 编辑圆框：图片不变，圆框可移动/缩放
      ctx.drawImage(img, 0, 0);
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, 0, editor.width, editor.height);
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.strokeStyle = '#28a745';
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  }

  function setMode(newMode) {
    if (!img) {
      mode = newMode;
      return;
    }
    if (newMode === mode) return;

    // 模式切换时尽量保持“选中的实际图像区域”不变
    if (mode === 'fixed' && newMode === 'edit') {
      // fixed -> edit: 把 frame + transform 换算到 image space 的 (cx,cy,r)
      const icx = (frameX - imgTx) / imgScale;
      const icy = (frameY - imgTy) / imgScale;
      const ir  = frameR / imgScale;
      cx = icx; cy = icy; r = ir;
      clampSelection();

      // 回到 edit 模式时，把图片变换归零，让圆框坐标直观
      imgScale = 1; imgTx = 0; imgTy = 0;
    } else if (mode === 'edit' && newMode === 'fixed') {
      // edit -> fixed: 固定圆框放在画布中心，通过缩放/平移图片来保持选中区域不变
      frameX = editor.width / 2;
      frameY = editor.height / 2;
      if (!frameR || frameR <= 0) frameR = Math.min(editor.width, editor.height) * 0.35;

      const safeR = Math.max(10, r);
      imgScale = frameR / safeR;
      imgTx = frameX - imgScale * cx;
      imgTy = frameY - imgScale * cy;

      clampImageTransform();
    }

    mode = newMode;
    drawEditor();
  }

  document.querySelectorAll('input[name="mode"]').forEach(el => {
    el.addEventListener('change', (e) => setMode(e.target.value));
  });

  // ---- 上传 ----
  upload.addEventListener('change', (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      img = new Image();
      img.onload = () => {
        editor.width = img.width;
        editor.height = img.height;

        // 初始化：edit 模式的圆（image space）
        cx = img.width / 2;
        cy = img.height / 2;
        r  = Math.min(img.width, img.height) / 2;

        // 初始化：fixed 模式的 frame（canvas space）
        frameX = cx;
        frameY = cy;
        frameR = Math.min(img.width, img.height) * 0.35;

        // 初始化图片变换
        imgScale = 1; imgTx = 0; imgTy = 0;
        clampSelection();
        clampImageTransform();

        resultContainer.style.display = 'none';
        setNote('');
        drawEditor();
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  });

  // ---- 鼠标拖拽 ----
  editor.addEventListener('mousedown', (e) => {
    if (!img) return;
    isDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });
  window.addEventListener('mouseup', () => isDragging = false);
  window.addEventListener('mousemove', (e) => {
    if (!img || !isDragging) return;

    const rect = editor.getBoundingClientRect();
    const scaleX = editor.width / rect.width;
    const scaleY = editor.height / rect.height;
    const dx = (e.clientX - lastX) * scaleX;
    const dy = (e.clientY - lastY) * scaleY;

    lastX = e.clientX;
    lastY = e.clientY;

    if (mode === 'fixed') {
      imgTx += dx;
      imgTy += dy;
      clampImageTransform();
    } else {
      cx += dx;
      cy += dy;
      clampSelection();
    }
    drawEditor();
  });

  // ---- 滚轮缩放 ----
  editor.addEventListener('wheel', (e) => {
    if (!img) return;
    e.preventDefault();

    const zoomSpeed = 0.08;
    const factor = (e.deltaY > 0) ? (1 - zoomSpeed) : (1 + zoomSpeed);

    if (mode === 'fixed') {
      const pos = getEventPos(e, false);
      const oldS = imgScale;
      const newS = oldS * factor;

      // 以鼠标位置为缩放中心
      imgScale = newS;
      imgTx = pos.x - (pos.x - imgTx) * (newS / oldS);
      imgTy = pos.y - (pos.y - imgTy) * (newS / oldS);

      clampImageTransform();
    } else {
      r *= factor;
      clampSelection();
    }
    drawEditor();
  }, { passive: false });

  // ---- 触摸：拖拽/捏合 ----
  editor.addEventListener('touchstart', (e) => {
    if (!img) return;

    if (e.touches.length === 1) {
      isDragging = true;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
      isDragging = false;
      lastDist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      lastPinchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      lastPinchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    }
  }, { passive: false });

  function endTouch() {
    isDragging = false;
    lastDist = 0;
  }
  window.addEventListener('touchend', endTouch, { passive: true });
  window.addEventListener('touchcancel', endTouch, { passive: true });

  editor.addEventListener('touchmove', (e) => {
    if (!img) return;
    e.preventDefault();

    const rect = editor.getBoundingClientRect();
    const scaleX = editor.width / rect.width;
    const scaleY = editor.height / rect.height;

    if (e.touches.length === 1 && isDragging) {
      const dx = (e.touches[0].clientX - lastX) * scaleX;
      const dy = (e.touches[0].clientY - lastY) * scaleY;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;

      if (mode === 'fixed') {
        imgTx += dx;
        imgTy += dy;
        clampImageTransform();
      } else {
        cx += dx;
        cy += dy;
        clampSelection();
      }
      drawEditor();
    } else if (e.touches.length === 2) {
      const dist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      if (lastDist <= 0) lastDist = dist;

      const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

      const ratio = dist / lastDist;
      lastDist = dist;

      if (mode === 'fixed') {
        const oldS = imgScale;
        const newS = oldS * ratio;

        // pinch center 转 canvas 坐标
        const cxCanvas = (centerX - rect.left) * scaleX;
        const cyCanvas = (centerY - rect.top) * scaleY;

        imgScale = newS;
        imgTx = cxCanvas - (cxCanvas - imgTx) * (newS / oldS);
        imgTy = cyCanvas - (cyCanvas - imgTy) * (newS / oldS);

        // 同时跟随 pinch center 的平移（更贴手）
        const dCenterX = (centerX - lastPinchCenterX) * scaleX;
        const dCenterY = (centerY - lastPinchCenterY) * scaleY;
        lastPinchCenterX = centerX;
        lastPinchCenterY = centerY;

        imgTx += dCenterX;
        imgTy += dCenterY;

        clampImageTransform();
      } else {
        r *= ratio;
        clampSelection();
      }
      drawEditor();
    }
  }, { passive: false });

  // ------------------ WebGL：保形映射渲染（保持原数学实现） ------------------
  const vsSource = `
    attribute vec2 a_position;
    varying vec2 v_uv;
    void main() {
      v_uv = a_position * 0.5 + 0.5;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  const fsSource = `
    precision highp float;
    varying vec2 v_uv;
    uniform sampler2D u_image;
    uniform vec2 u_center;
    uniform float u_radius;
    uniform vec2 u_resolution;

    vec2 c_mul(vec2 a, vec2 b) { 
      return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); 
    }
    vec2 c_div(vec2 a, vec2 b) { 
      float d = dot(b,b); 
      return vec2(dot(a,b), a.y*b.x - a.x*b.y) / d; 
    }

    float sinh(float x) { return (exp(x) - exp(-x)) * 0.5; }
    float cosh(float x) { return (exp(x) + exp(-x)) * 0.5; }

    vec2 c_sin(vec2 z) { return vec2(sin(z.x)*cosh(z.y), cos(z.x)*sinh(z.y)); }
    vec2 c_cos(vec2 z) { return vec2(cos(z.x)*cosh(z.y), -sin(z.x)*sinh(z.y)); }

    // q = e^-PI
    const float Q_1_4 = 0.455901411;
    const float Q_9_4 = 0.000851622;
    const float Q_1   = 0.043213918;
    const float Q_4   = 0.000003480;

    vec2 theta1(vec2 z) {
      return 2.0 * (Q_1_4 * c_sin(z) - Q_9_4 * c_sin(3.0 * z));
    }
    vec2 theta3(vec2 z) {
      return vec2(1.0, 0.0) + 2.0 * (Q_1 * c_cos(2.0 * z) + Q_4 * c_cos(4.0 * z));
    }

    void main() {
      float X = v_uv.x * 2.0 - 1.0;
      float Y = v_uv.y * 2.0 - 1.0;

      vec2 zeta = 0.785398163 * vec2(X + Y, Y - X);

      vec2 t1 = theta1(zeta);
      vec2 t3 = theta3(zeta);
      vec2 ratio = c_div(t1, t3);

      vec2 z = c_mul(vec2(0.707106781, 0.707106781), ratio);

      vec2 pixelPos = u_center + vec2(z.x, -z.y) * u_radius;
      vec2 texCoord = pixelPos / u_resolution;

      if (length(z) > 1.0001) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
      } else {
        gl_FragColor = texture2D(u_image, texCoord);
      }
    }
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(shader) || 'Shader 编译失败';
      console.error(info);
      gl.deleteShader(shader);
      throw new Error(info);
    }
    return shader;
  }

  // ---- WebGL 资源复用 ----
  const renderer = {
    gl: null,
    isWebGL2: false,
    program: null,
    positionBuffer: null,
    texture: null,
    loc: {},
    lastImg: null,
    lastInterp: null,
  };

  function initGL() {
    if (renderer.gl) return renderer.gl;

    // 预览/导出都走同一个 output canvas，这里先用 preserveDrawingBuffer 保持下载简单
    const opts = { preserveDrawingBuffer: true, antialias: true };

    let gl = output.getContext('webgl2', opts);
    renderer.isWebGL2 = !!gl;
    if (!gl) gl = output.getContext('webgl', opts);
    if (!gl) throw new Error('当前浏览器不支持 WebGL');

    // 编译/链接
    const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(program) || 'Program 链接失败';
      console.error(info);
      throw new Error(info);
    }

    // buffer
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1.0, -1.0,   1.0, -1.0,  -1.0,  1.0,
      -1.0,  1.0,   1.0, -1.0,   1.0,  1.0
    ]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    gl.useProgram(program);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    renderer.gl = gl;
    renderer.program = program;
    renderer.positionBuffer = positionBuffer;
    renderer.texture = texture;
    renderer.loc = {
      u_image: gl.getUniformLocation(program, 'u_image'),
      u_center: gl.getUniformLocation(program, 'u_center'),
      u_radius: gl.getUniformLocation(program, 'u_radius'),
      u_resolution: gl.getUniformLocation(program, 'u_resolution'),
    };

    return gl;
  }

  function applyTextureSampling(gl, interpMode) {
    // interpMode: nearest | linear | mipmap
    const isMipmap = interpMode === 'mipmap';

    if (isMipmap && !renderer.isWebGL2) {
      // WebGL1 对 NPOT 纹理不能用 mipmap；这里降级为 linear
      setNote('提示：当前是 WebGL1，MipMap 对非 2 的幂纹理不可用，已自动使用 Linear。');
      interpMode = 'linear';
    } else {
      setNote('');
    }

    gl.bindTexture(gl.TEXTURE_2D, renderer.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    if (interpMode === 'nearest') {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    } else if (interpMode === 'mipmap') {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }

    renderer.lastInterp = interpMode;
    return interpMode;
  }

  function uploadTextureIfNeeded(gl) {
    if (!img) return;
    if (renderer.lastImg === img) return;

    gl.bindTexture(gl.TEXTURE_2D, renderer.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

    renderer.lastImg = img;
  }

  function computeSelectionInImageSpace() {
    if (mode === 'fixed') {
      const icx = (frameX - imgTx) / imgScale;
      const icy = (frameY - imgTy) / imgScale;
      const ir  = frameR / imgScale;
      return { cx: icx, cy: icy, r: ir };
    }
    return { cx, cy, r };
  }

  function computeOutputSize(radiusImg) {
    const scale = parseFloat(outScaleSel.value || '1.2');
    let cap = parseInt(outCapSel.value || '2048', 10);
    if (!cap || cap <= 0) cap = Number.POSITIVE_INFINITY;

    // 自适应：跟随选区大小，但给一个更温和的默认（不强制 1024 起步）
    const raw = Math.round(radiusImg * 2 * scale);
    const size = Math.max(512, Math.min(cap, raw));
    return size;
  }

  function renderOnce() {
    if (!img) throw new Error('请先上传图片');

    const sel = computeSelectionInImageSpace();
    // 用 clampSelection 让参数更稳（不改 A 数学部分）
    cx = sel.cx; cy = sel.cy; r = sel.r;
    clampSelection();

    const size = computeOutputSize(r);

    // Resize output canvas
    output.width = size;
    output.height = size;

    const gl = initGL();

    gl.useProgram(renderer.program);
    gl.bindBuffer(gl.ARRAY_BUFFER, renderer.positionBuffer);

    uploadTextureIfNeeded(gl);

    const chosenInterp = applyTextureSampling(gl, interpSel.value);
    if (chosenInterp === 'mipmap') {
      // WebGL2: 允许 NPOT mipmap
      gl.generateMipmap(gl.TEXTURE_2D);
    }

    gl.uniform1i(renderer.loc.u_image, 0);
    gl.uniform2f(renderer.loc.u_center, cx, cy);
    gl.uniform1f(renderer.loc.u_radius, r);
    gl.uniform2f(renderer.loc.u_resolution, img.width, img.height);

    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    resultContainer.style.display = 'block';
  }

  processBtn.addEventListener('click', () => {
    if (!img) return alert('请先上传图片！');

    processBtn.disabled = true;
    processBtn.textContent = '生成中…';

    try {
      renderOnce();
    } catch (err) {
      console.error(err);
      alert(String(err && err.message ? err.message : err));
    } finally {
      processBtn.disabled = false;
      processBtn.textContent = '生成结果';
    }
  });

  function downloadImg(format) {
    if (!output.width || !output.height) return alert('请先生成结果');
    const type = format === 'jpg' ? 'image/jpeg' : 'image/png';
    const url = output.toDataURL(type, 0.95);
    const a = document.createElement('a');
    a.href = url;
    a.download = `mapped.${format}`;
    a.click();
  }

  dlPngBtn.addEventListener('click', () => downloadImg('png'));
  dlJpgBtn.addEventListener('click', () => downloadImg('jpg'));

  // 当插值选项变动时，提前给出提示（尤其是 mipmap）
  interpSel.addEventListener('change', () => {
    if (interpSel.value === 'mipmap') {
      setNote(renderer.isWebGL2 ? '' : '提示：MipMap 需要 WebGL2；WebGL1 会自动降级为 Linear。');
    } else {
      setNote('');
    }
  });
})();
</script>
</body>
</html>
